"""
Alert rule model for defining monitoring conditions and notification preferences.

This module provides the database model for alert rules that define the conditions
under which alerts should be triggered and how they should be delivered. Alert rules
enable flexible, configurable monitoring of energy data, system health, and operational
metrics with sophisticated targeting and delivery options.

Key Features:
- Flexible JSON-based condition configuration for any monitoring scenario
- Area and data type targeting for granular monitoring scope
- Multi-channel delivery configuration with channel-specific settings
- Rule lifecycle management with status control
- Performance-optimized indexing for efficient rule evaluation
- Comprehensive audit trail with timestamps
"""

from __future__ import annotations

from datetime import UTC, datetime, timedelta
from typing import TYPE_CHECKING, Any

from sqlalchemy import JSON, Boolean, Index, Integer, String, Text
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .alert_enums import AlertDeliveryChannel, AlertRuleStatus, AlertSeverity, AlertType
from .base import TimestampedModel
from .load_data import EnergyDataType

if TYPE_CHECKING:
    from .alert import Alert


class AlertRule(TimestampedModel):
    """
    Model for defining alert rules with conditions, targeting, and delivery configuration.

    This model enables the creation of flexible, configurable alert rules that can
    monitor various aspects of the energy data system. Rules can target specific
    geographic areas and data types, with sophisticated condition evaluation and
    multi-channel delivery capabilities.

    Attributes:
        id: Primary key for the alert rule record
        name: Human-readable name for the alert rule for management and identification
        description: Detailed description explaining the purpose and behavior of the rule
        alert_type: Type of alert this rule generates (price_threshold, data_quality, etc.)
        severity: Default severity level for alerts generated by this rule
        status: Current operational status of the rule (active, inactive, paused)
        conditions: JSON configuration defining the specific conditions that trigger alerts
        area_codes: JSON array of geographic area codes this rule monitors (e.g., ['DE', 'FR'])
        data_types: JSON array of energy data types this rule monitors
        delivery_channels: JSON configuration for alert delivery preferences and settings
        is_global: Whether this rule applies globally or only to specified areas/data types
        evaluation_interval_minutes: How frequently this rule should be evaluated (in minutes)
        cooldown_minutes: Minimum time between alerts to prevent spam (in minutes)
        max_alerts_per_day: Maximum number of alerts this rule can generate per day
        last_triggered: Timestamp when this rule last generated an alert
        trigger_count: Total number of times this rule has been triggered
        created_at: Timestamp when this rule was created (inherited)
        updated_at: Timestamp when this rule was last updated (inherited)
    """

    __tablename__ = "alert_rules"

    # Primary identification
    id: Mapped[int] = mapped_column(
        Integer,
        primary_key=True,
        autoincrement=True,
        comment="Primary key for alert rule record",
    )

    name: Mapped[str] = mapped_column(
        String(200),
        nullable=False,
        unique=True,
        index=True,
        comment="Human-readable name for alert rule management",
    )

    description: Mapped[str | None] = mapped_column(
        Text,
        nullable=True,
        comment="Detailed description of rule purpose and behavior",
    )

    # Alert classification
    alert_type: Mapped[AlertType] = mapped_column(
        nullable=False,
        index=True,
        comment="Type of alert this rule generates",
    )

    severity: Mapped[AlertSeverity] = mapped_column(
        nullable=False,
        index=True,
        comment="Default severity level for generated alerts",
    )

    status: Mapped[AlertRuleStatus] = mapped_column(
        nullable=False,
        default=AlertRuleStatus.ACTIVE,
        index=True,
        comment="Current operational status of the rule",
    )

    # Rule configuration
    conditions: Mapped[dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        comment="JSON configuration defining alert trigger conditions",
    )

    # Targeting configuration
    area_codes: Mapped[list[str] | None] = mapped_column(
        JSON,
        nullable=True,
        comment="JSON array of geographic area codes to monitor",
    )

    data_types: Mapped[list[str] | None] = mapped_column(
        JSON,
        nullable=True,
        comment="JSON array of energy data types to monitor",
    )

    is_global: Mapped[bool] = mapped_column(
        Boolean,
        nullable=False,
        default=False,
        index=True,
        comment="Whether rule applies globally or only to specified areas/types",
    )

    # Delivery configuration
    delivery_channels: Mapped[dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        comment="JSON configuration for alert delivery preferences and settings",
    )

    # Evaluation and throttling
    evaluation_interval_minutes: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        default=15,
        comment="Frequency of rule evaluation in minutes",
    )

    cooldown_minutes: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        default=60,
        comment="Minimum time between alerts to prevent spam",
    )

    max_alerts_per_day: Mapped[int | None] = mapped_column(
        Integer,
        nullable=True,
        comment="Maximum alerts per day (null for unlimited)",
    )

    # Execution tracking
    last_triggered: Mapped[datetime | None] = mapped_column(
        nullable=True,
        comment="Timestamp when rule last generated an alert",
    )

    trigger_count: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        default=0,
        comment="Total number of times this rule has been triggered",
    )

    # Relationship to alerts
    alerts: Mapped[list[Alert]] = relationship(
        "Alert",
        back_populates="alert_rule",
        lazy="dynamic",
        cascade="all, delete-orphan",
    )

    # Composite indexes for efficient querying
    __table_args__ = (
        # Index for active rule evaluation (most common query pattern)
        Index("ix_alert_rules_status_type", "status", "alert_type"),
        # Index for global vs targeted rule filtering
        Index("ix_alert_rules_global_status", "is_global", "status"),
        # Index for evaluation scheduling
        Index("ix_alert_rules_evaluation_time", "status", "last_triggered"),
        # Index for severity-based filtering and alerting
        Index("ix_alert_rules_severity_status", "severity", "status"),
        # Index for rule type and status combinations
        Index("ix_alert_rules_type_severity", "alert_type", "severity"),
        {"comment": "Alert rules for monitoring energy data and system conditions"},
    )

    def __repr__(self) -> str:
        """String representation for debugging and logging."""
        return (
            f"AlertRule(id={self.id}, name='{self.name}', "
            f"type={self.alert_type.value}, severity={self.severity.value}, "
            f"status={self.status.value}, triggers={self.trigger_count})"
        )

    @property
    def is_active(self) -> bool:
        """Check if the rule is currently active and can generate alerts."""
        return self.status == AlertRuleStatus.ACTIVE

    @property
    def is_cooldown_active(self) -> bool:
        """Check if the rule is currently in cooldown period."""
        if self.last_triggered is None:
            return False

        cooldown_end = self.last_triggered + timedelta(minutes=self.cooldown_minutes)
        return datetime.now(UTC) < cooldown_end

    @property
    def has_area_targeting(self) -> bool:
        """Check if the rule has specific area code targeting."""
        return self.area_codes is not None and len(self.area_codes) > 0

    @property
    def has_data_type_targeting(self) -> bool:
        """Check if the rule has specific data type targeting."""
        return self.data_types is not None and len(self.data_types) > 0

    @property
    def configured_delivery_channels(self) -> list[AlertDeliveryChannel]:
        """Get list of configured delivery channels for this rule."""
        channels = []
        if isinstance(self.delivery_channels, dict):
            for channel_name in self.delivery_channels:
                try:
                    channel = AlertDeliveryChannel(channel_name)
                    channels.append(channel)
                except ValueError:
                    # Skip invalid channel names
                    continue
        return channels

    @property
    def has_email_delivery(self) -> bool:
        """Check if email delivery is configured for this rule."""
        return AlertDeliveryChannel.EMAIL in self.configured_delivery_channels

    @property
    def has_webhook_delivery(self) -> bool:
        """Check if webhook delivery is configured for this rule."""
        return AlertDeliveryChannel.WEBHOOK in self.configured_delivery_channels

    @property
    def is_rate_limited(self) -> bool:
        """Check if the rule has hit its daily alert limit."""
        if self.max_alerts_per_day is None:
            return False

        # This would need integration with alert counting logic
        # For now, return False as the actual implementation would require
        # querying the alerts table for today's count
        return False

    def can_trigger_alert(self) -> bool:
        """
        Check if the rule can currently trigger an alert.

        Considers rule status, cooldown period, and rate limiting.

        Returns:
            True if the rule can trigger an alert, False otherwise
        """
        return (
            self.is_active and not self.is_cooldown_active and not self.is_rate_limited
        )

    def get_condition_value(self, key: str, default: Any = None) -> Any:
        """
        Get a specific condition value from the conditions JSON.

        Args:
            key: The condition key to retrieve
            default: Default value if key is not found

        Returns:
            The condition value or default if not found
        """
        return self.conditions.get(key, default)

    def get_delivery_config(self, channel: AlertDeliveryChannel) -> dict[str, Any]:
        """
        Get delivery configuration for a specific channel.

        Args:
            channel: The delivery channel to get configuration for

        Returns:
            Dictionary containing channel-specific configuration
        """
        config = self.delivery_channels.get(channel.value, {})
        return config if isinstance(config, dict) else {}
