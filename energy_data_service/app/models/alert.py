"""
Alert model for tracking individual alert instances and delivery status.

This module provides the database model for individual alerts generated by alert rules.
Each alert represents a specific occurrence of a monitored condition, with full context
about what triggered it, how it should be delivered, and tracking of delivery attempts
and status across multiple channels.

Key Features:
- Alert rule relationship for traceability and rule management
- Rich context capture for alert investigation and debugging
- Multi-channel delivery tracking with status and attempt monitoring
- Alert correlation and deduplication capabilities
- Time-series optimized storage for high-volume alert scenarios
- Comprehensive audit trail for compliance and troubleshooting
"""

from __future__ import annotations

from datetime import UTC, datetime
from typing import TYPE_CHECKING, Any

from sqlalchemy import JSON, DateTime, ForeignKey, Index, Integer, String, Text
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .alert_enums import AlertDeliveryStatus, AlertSeverity, AlertType
from .base import TimestampedModel

if TYPE_CHECKING:
    from .alert_rule import AlertRule


class Alert(TimestampedModel):
    """
    Model for individual alert instances with delivery tracking and correlation.

    This model represents a specific alert occurrence generated by an alert rule
    when monitored conditions are met. It captures the full context of what
    triggered the alert, manages delivery across multiple channels, and provides
    correlation capabilities for deduplication and related alert grouping.

    Attributes:
        id: Primary key for the alert record
        alert_rule_id: Foreign key reference to the AlertRule that generated this alert
        alert_rule: Relationship to the parent AlertRule (loaded when needed)
        alert_type: Type of alert (inherited from rule but stored for efficient querying)
        severity: Severity level (inherited from rule but may be overridden)
        title: Short, descriptive title summarizing the alert condition
        message: Detailed message explaining the alert condition and context
        triggered_at: Timestamp when the alert condition was detected
        triggered_by: Identifier of the process/job that detected the condition
        trigger_context: JSON containing detailed context about what triggered the alert
        correlation_key: Key for grouping related alerts and deduplication
        area_code: Geographic area code if alert is area-specific
        data_type: Energy data type if alert is data-type-specific
        delivery_status: Overall delivery status across all configured channels
        delivery_attempts: Number of delivery attempts made
        last_delivery_attempt: Timestamp of the most recent delivery attempt
        delivery_details: JSON containing per-channel delivery status and metadata
        resolved_at: Timestamp when the alert condition was resolved (if applicable)
        resolved_by: Identifier of who/what resolved the alert
        resolution_notes: Notes about how the alert was resolved
        alert_metadata: Additional JSON metadata for extensibility
        created_at: Timestamp when this alert was created (inherited)
        updated_at: Timestamp when this alert was last updated (inherited)
    """

    __tablename__ = "alerts"

    # Primary identification
    id: Mapped[int] = mapped_column(
        Integer,
        primary_key=True,
        autoincrement=True,
        comment="Primary key for alert record",
    )

    alert_rule_id: Mapped[int] = mapped_column(
        ForeignKey("alert_rules.id", ondelete="CASCADE"),
        nullable=False,
        index=True,
        comment="Foreign key reference to the generating alert rule",
    )

    # Relationship to alert rule
    alert_rule: Mapped[AlertRule] = relationship(
        "AlertRule",
        lazy="select",
        back_populates="alerts",
    )

    # Alert classification (denormalized for performance)
    alert_type: Mapped[AlertType] = mapped_column(
        nullable=False,
        index=True,
        comment="Type of alert (denormalized from rule for efficient querying)",
    )

    severity: Mapped[AlertSeverity] = mapped_column(
        nullable=False,
        index=True,
        comment="Alert severity level (from rule or overridden)",
    )

    # Alert content
    title: Mapped[str] = mapped_column(
        String(500),
        nullable=False,
        comment="Short descriptive title summarizing the alert condition",
    )

    message: Mapped[str] = mapped_column(
        Text,
        nullable=False,
        comment="Detailed message explaining the alert condition and context",
    )

    # Trigger information
    triggered_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        nullable=False,
        comment="Timestamp when the alert condition was detected",
    )

    triggered_by: Mapped[str | None] = mapped_column(
        String(100),
        nullable=True,
        comment="Identifier of the process/job that detected the condition",
    )

    trigger_context: Mapped[dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        comment="JSON containing detailed context about what triggered the alert",
    )

    # Correlation and targeting
    correlation_key: Mapped[str | None] = mapped_column(
        String(200),
        nullable=True,
        index=True,
        comment="Key for grouping related alerts and deduplication",
    )

    area_code: Mapped[str | None] = mapped_column(
        String(10),
        nullable=True,
        index=True,
        comment="Geographic area code if alert is area-specific",
    )

    data_type: Mapped[str | None] = mapped_column(
        String(50),
        nullable=True,
        index=True,
        comment="Energy data type if alert is data-type-specific",
    )

    # Delivery tracking
    delivery_status: Mapped[AlertDeliveryStatus] = mapped_column(
        nullable=False,
        default=AlertDeliveryStatus.PENDING,
        index=True,
        comment="Overall delivery status across all configured channels",
    )

    delivery_attempts: Mapped[int] = mapped_column(
        Integer,
        nullable=False,
        default=0,
        comment="Number of delivery attempts made",
    )

    last_delivery_attempt: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        comment="Timestamp of the most recent delivery attempt",
    )

    delivery_details: Mapped[dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        default=dict,
        comment="JSON containing per-channel delivery status and metadata",
    )

    # Resolution tracking
    resolved_at: Mapped[datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        index=True,
        comment="Timestamp when the alert condition was resolved",
    )

    resolved_by: Mapped[str | None] = mapped_column(
        String(100),
        nullable=True,
        comment="Identifier of who/what resolved the alert",
    )

    resolution_notes: Mapped[str | None] = mapped_column(
        Text,
        nullable=True,
        comment="Notes about how the alert was resolved",
    )

    # Extensibility
    alert_metadata: Mapped[dict[str, Any]] = mapped_column(
        JSON,
        nullable=False,
        default=dict,
        comment="Additional JSON metadata for extensibility",
    )

    # Composite indexes for efficient querying
    __table_args__ = (
        # Index for time-based queries (most common query pattern)
        Index("ix_alerts_triggered_at", "triggered_at"),
        # Index for rule-based filtering with time
        Index("ix_alerts_rule_time", "alert_rule_id", "triggered_at"),
        # Index for status-based queries and delivery processing
        Index("ix_alerts_delivery_status_time", "delivery_status", "triggered_at"),
        # Index for severity-based filtering and escalation
        Index("ix_alerts_severity_time", "severity", "triggered_at"),
        # Index for alert type analysis
        Index("ix_alerts_type_time", "alert_type", "triggered_at"),
        # Index for area-specific alert queries
        Index("ix_alerts_area_time", "area_code", "triggered_at"),
        # Index for correlation and deduplication
        Index("ix_alerts_correlation_time", "correlation_key", "triggered_at"),
        # Index for resolution tracking
        Index("ix_alerts_resolution_status", "resolved_at", "severity"),
        # Composite index for delivery processing
        Index(
            "ix_alerts_delivery_processing",
            "delivery_status",
            "delivery_attempts",
            "last_delivery_attempt",
        ),
        # Composite index for active alert monitoring
        Index(
            "ix_alerts_active_monitoring",
            "resolved_at",
            "severity",
            "triggered_at",
        ),
        {
            "comment": "Individual alert instances with delivery tracking and correlation"
        },
    )

    def __repr__(self) -> str:
        """String representation for debugging and logging."""
        return (
            f"Alert(id={self.id}, rule_id={self.alert_rule_id}, "
            f"type={self.alert_type.value}, severity={self.severity.value}, "
            f"status={self.delivery_status.value}, triggered={self.triggered_at})"
        )

    @property
    def is_resolved(self) -> bool:
        """Check if the alert has been resolved."""
        return self.resolved_at is not None

    @property
    def is_pending_delivery(self) -> bool:
        """Check if the alert is pending delivery."""
        return self.delivery_status == AlertDeliveryStatus.PENDING

    @property
    def is_delivered(self) -> bool:
        """Check if the alert has been successfully delivered."""
        return self.delivery_status == AlertDeliveryStatus.DELIVERED

    @property
    def delivery_failed(self) -> bool:
        """Check if alert delivery has failed."""
        return self.delivery_status == AlertDeliveryStatus.FAILED

    @property
    def is_retrying_delivery(self) -> bool:
        """Check if alert delivery is being retried."""
        return self.delivery_status == AlertDeliveryStatus.RETRYING

    @property
    def duration_until_resolved(self) -> float | None:
        """
        Calculate duration from trigger to resolution in seconds.

        Returns:
            Duration in seconds if resolved, None if still active
        """
        if not self.is_resolved or self.resolved_at is None:
            return None

        duration = self.resolved_at - self.triggered_at
        return duration.total_seconds()

    @property
    def time_since_triggered(self) -> float:
        """Calculate time since alert was triggered in seconds."""
        duration = datetime.now(UTC) - self.triggered_at
        return duration.total_seconds()

    @property
    def has_correlation_key(self) -> bool:
        """Check if the alert has a correlation key for grouping."""
        return (
            self.correlation_key is not None and len(self.correlation_key.strip()) > 0
        )

    @property
    def is_area_specific(self) -> bool:
        """Check if the alert is specific to a geographic area."""
        return self.area_code is not None and len(self.area_code.strip()) > 0

    @property
    def is_data_type_specific(self) -> bool:
        """Check if the alert is specific to an energy data type."""
        return self.data_type is not None and len(self.data_type.strip()) > 0

    def get_delivery_status_for_channel(
        self, channel: str
    ) -> AlertDeliveryStatus | None:
        """
        Get delivery status for a specific channel.

        Args:
            channel: The delivery channel name

        Returns:
            Delivery status for the channel or None if not found
        """
        channel_details = self.delivery_details.get(channel, {})
        if not isinstance(channel_details, dict):
            return None

        status_str = channel_details.get("status")
        if status_str is None:
            return None

        try:
            return AlertDeliveryStatus(status_str)
        except ValueError:
            return None

    def get_trigger_context_value(self, key: str, default: Any = None) -> Any:
        """
        Get a specific value from the trigger context.

        Args:
            key: The context key to retrieve
            default: Default value if key is not found

        Returns:
            The context value or default if not found
        """
        return self.trigger_context.get(key, default)

    def get_metadata_value(self, key: str, default: Any = None) -> Any:
        """
        Get a specific value from the alert_metadata.

        Args:
            key: The metadata key to retrieve
            default: Default value if key is not found

        Returns:
            The metadata value or default if not found
        """
        return self.alert_metadata.get(key, default)

    def add_delivery_attempt(
        self,
        channel: str,
        status: AlertDeliveryStatus,
        details: dict[str, Any] | None = None,
    ) -> None:
        """
        Record a delivery attempt for a specific channel.

        Args:
            channel: The delivery channel name
            status: The delivery status for this attempt
            details: Optional additional details about the delivery attempt
        """
        attempt_details = {
            "status": status.value,
            "attempted_at": datetime.now(UTC).isoformat(),
            "details": details or {},
        }

        self.delivery_details[channel] = attempt_details
        self.delivery_attempts += 1
        self.last_delivery_attempt = datetime.now(UTC)

    def mark_resolved(
        self, resolved_by: str | None = None, notes: str | None = None
    ) -> None:
        """
        Mark the alert as resolved.

        Args:
            resolved_by: Identifier of who/what resolved the alert
            notes: Optional notes about the resolution
        """
        self.resolved_at = datetime.now(UTC)
        self.resolved_by = resolved_by
        self.resolution_notes = notes
